<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ— (UIæ”¹å–„ç‰ˆ + ãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆ)</title>

    <!-- Tailwind ã‚’CDNã§èª­ã¿è¾¼ã¿ï¼ˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹ç”¨ï¼‰ -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Google Fonts ã®èª­ã¿è¾¼ã¿ */
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap');

        /* --------- åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå…¨ä½“ï¼‰ --------- */
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #1a202c; /* ãƒ€ãƒ¼ã‚¯èƒŒæ™¯ */
            color: #e2e8f0;            /* æ–‡å­—è‰²ï¼ˆè–„ã„ã‚°ãƒ¬ãƒ¼ï¼‰ */
            user-select: none;         /* ãƒ†ã‚­ã‚¹ãƒˆé¸æŠç¦æ­¢ï¼ˆãƒ‰ãƒ©ãƒƒã‚°èª¤æ“ä½œé˜²æ­¢ï¼‰ */
        }

        /* --------- ç›¤é¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ --------- */
        .game-container { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 1rem; }
        .game-board {
            /* ä¸Šæ®µï¼šç›¸æ‰‹ã€ä¸‹æ®µï¼šè‡ªåˆ† ã®2è¡Œã‚°ãƒªãƒƒãƒ‰ */
            display: grid; grid-template-rows: 1fr 1fr;
            width: 100%; max-width: 1200px; height: 85vh; gap: 1rem;
            border: 2px solid #4a5568; border-radius: 1rem;
            background-color: #2d3748; position: relative;
        }
        .player-area { border: 2px dashed #4a5568; border-radius: 0.75rem; padding: 1rem; position: relative; display: flex; flex-direction: column; transition: all 0.3s ease; }

        /* ç¾åœ¨ã®æ‰‹ç•ªã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å…‰ã‚‹æ ã‚’ä»˜ã‘ã‚‹ */
        .player-area.active-player {
            border-color: #63b3ed;
            box-shadow: 0 0 20px rgba(99, 179, 237, 0.5);
        }

        /* å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å†…ã®ã‚¾ãƒ¼ãƒ³é…ç½®ï¼ˆä¸Šï¼šãƒãƒˆãƒ«ï¼‹ãƒ™ãƒ³ãƒã€ä¸‹ï¼šæ‰‹æœ­ï¼‰ */
        .main-area { display: flex; height: 60%; border-bottom: 2px dashed #4a5568; }
        .battle-zone { width: 30%; display: flex; justify-content: center; align-items: center; }
        .bench-zone { width: 70%; display: flex; justify-content: center; align-items: center; gap: 0.5rem; padding: 0.5rem; border-left: 2px dashed #4a5568; }
        .hand-zone { height: 40%; display: flex; justify-content: center; align-items: flex-end; padding-bottom: 1rem; }

        /* å±±æœ­ãƒ»ãƒˆãƒ©ãƒƒã‚·ãƒ¥ãƒ»ã‚µã‚¤ãƒ‰ãªã©ã®ã‚µãƒ–UIï¼ˆå³ä¸‹ã«ã¾ã¨ã‚ï¼‰ */
        .side-area { position: absolute; bottom: 1rem; right: 1rem; display: flex; flex-direction: column; align-items: center; gap: 0.5rem; }
        .prize-area { width: 80px; text-align: center; font-weight: bold; background-color: rgba(0,0,0,0.3); border-radius: 0.5rem; padding: 0.25rem; }
        .deck-zone, .discard-pile {
            width: 80px; height: 112px; border: 2px solid #a0aec0; border-radius: 0.5rem;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            transition: all 0.2s ease; font-size: 0.8rem; text-align: center;
        }
        .deck-zone { background-color: #4a5568; cursor: pointer; }
        .discard-pile { background-color: #2d3748; }
        .deck-zone:hover { transform: scale(1.05); border-color: #cbd5e0; }

        /* --------- ã‚«ãƒ¼ãƒ‰è¦‹ãŸç›® --------- */
        .card {
            width: 80px; height: 112px; border-radius: 0.5rem; padding: 0.4rem; cursor: pointer;
            transition: all 0.3s ease; display: flex; flex-direction: column; justify-content: space-between;
            border: 2px solid #a0aec0; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); position: relative; flex-shrink: 0; font-weight: bold;
        }
        /* ã‚«ãƒ¼ãƒ‰ç¨®åˆ¥åˆ¥ã®è‰² */
        .card.pokemon-card { background-color: #e2e8f0; color: #1a202c; }
        .card.goods-card   { background-color: #38a169; color: white; border-color: #9ae6b4; }
        .card.support-card { background-color: #3182ce; color: white; border-color: #90cdf4; }

        /* æ‰‹æœ­ã®é‡ãªã‚Šã¨ãƒ›ãƒãƒ¼åŠ¹æœï¼ˆãµã‚ã£ã¨æŒã¡ä¸ŠãŒã‚‹ï¼‰ */
        .hand-zone .card { margin: 0 -10px; }
        .hand-zone .card:hover { transform: translateY(-20px) scale(1.1); z-index: 10; }

        /* ã‚«ãƒ¼ãƒ‰å†…éƒ¨ã®è¦ç´  */
        .card-name { font-size: 0.7rem; text-align: center; }
        .card-img { width: 100%; height: 40px; background-color: rgba(255,255,255,0.2); border-radius: 0.25rem; display: flex; justify-content: center; align-items: center; font-size: 1.5rem; }
        .pokemon-card .card-img { background-color: #cbd5e0; }
        .card-stats { display: flex; justify-content: space-around; font-size: 0.6rem; }
        .card-desc { font-size: 0.6rem; font-weight: normal; text-align: center; flex-grow: 1; display: flex; align-items: center; justify-content: center; }

        /* ç¾åœ¨HPã®ãƒãƒƒã‚¸ï¼ˆå³ä¸Šã®ä¸¸ï¼‰ */
        .current-hp { position: absolute; top: -8px; right: -8px; background-color: #c53030; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; justify-content: center; align-items: center; font-size: 0.6rem; font-weight: bold; border: 2px solid white; }

        /* ãƒãƒˆãƒ«å ´ç”¨ã«ã‚«ãƒ¼ãƒ‰ã‚’å°‘ã—å¤§ããè¦‹ã›ã‚‹ */
        .battle-card { cursor: default; width: 100px; height: 140px; }
        .battle-card .card-name { font-size: 0.8rem; }
        .battle-card .card-img { height: 60px; font-size: 2rem; }
        .battle-card .card-stats { font-size: 0.75rem; }
        .battle-card .current-hp { width: 30px; height: 30px; font-size: 0.7rem; top: -10px; right: -10px;}
        .battle-card:hover { transform: scale(1.1); }

        /* ç›¸æ‰‹å´ã®æ‰‹æœ­ã‚„ãƒ™ãƒ³ãƒã¯ä¼ã›ãŸè¦‹ãŸç›®ï¼ˆæƒ…å ±éš ã—ï¼‰ */
        #opponent-hand .card, #opponent-bench .card { background-color: #4a5568; color: transparent; border-color: #718096; }
        #opponent-deck { background-color: #718096; }

        /* --------- ç”»é¢ä¸‹ã®æ“ä½œãƒœã‚¿ãƒ³ --------- */
        .game-controls { display: flex; gap: 1rem; margin-top: 1rem; }
        .control-button { padding: 0.75rem 1.5rem; font-size: 1rem; background-color: #4299e1; color: white; border: none; border-radius: 0.5rem; cursor: pointer; transition: background-color 0.2s; }
        .control-button:hover:not(:disabled) { background-color: #3182ce; }
        .control-button:disabled { background-color: #a0aec0; cursor: not-allowed; }

        /* --------- ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆé–‹å§‹ï¼æº–å‚™ï¼æ˜‡æ ¼ï¼å‹æ•—ï¼ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºï¼å…¥ã‚Œæ›¿ãˆï¼‰ --------- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 50; }
        .modal-content { background-color: #2d3748; padding: 2rem; border-radius: 1rem; text-align: center; border: 2px solid #4a5568; max-width: 90%; }
        .modal-content h2 { font-size: 1.5rem; margin-bottom: 1rem; }
        .modal-content p { margin-bottom: 1.5rem; }
        #turn-announcement-modal { pointer-events: none; background-color: transparent; }
        #turn-announcement-text { text-shadow: 2px 2px 8px #000; animation: fadeInOut 2s forwards; }
        @keyframes fadeInOut { 0% { opacity: 0; transform: scale(0.8); } 25% { opacity: 1; transform: scale(1); } 75% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(1.2); } }

        /* æº–å‚™ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆé…ç½®UIï¼‰ */
        #promotion-options, #setup-bench-slots, #switch-options { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; }
        .game-info { width: 100%; max-width: 1200px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        #turn-indicator { font-size: 1.5rem; font-weight: bold; }
        #log { background-color: rgba(0,0,0,0.3); padding: 0.5rem; border-radius: 0.5rem; font-size: 0.9rem; height: 50px; overflow-y: auto; width: 50%; }
        .hidden { display: none; }
        #setup-modal .hand-zone { border-top: 2px dashed #4a5568; padding-top: 1rem; margin-top: 1rem; min-height: 150px; }
        .setup-area { margin-bottom: 1.5rem; }
        .setup-slots { display: flex; justify-content: center; gap: 0.5rem; min-height: 120px; }
        .setup-slot { width: 80px; height: 112px; border: 2px dashed #667eea; border-radius: 0.5rem; cursor: pointer; }
        .setup-slot.battle { border-color: #ed64a6; }
        .card.selected { border-color: #63b3ed; transform: scale(1.1); box-shadow: 0 0 15px #63b3ed; }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- ========== ãƒ¢ãƒ¼ãƒ€ãƒ«ç¾¤ï¼ˆé–‹å§‹ï¼æº–å‚™ï¼æ˜‡æ ¼ï¼ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ã‚¿ãƒ¼ãƒ³ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ï¼‰ ========== -->
        <div id="start-game-modal" class="modal-overlay">
            <div class="modal-content">
                <button id="start-game-button" class="control-button" style="font-size: 1.5rem; padding: 1.5rem 3rem;">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
            </div>
        </div>

        <!-- å¯¾æˆ¦æº–å‚™ï¼ˆæ‰‹æœ­ã‹ã‚‰ãƒãƒˆãƒ«1ä½“ï¼‹ãƒ™ãƒ³ãƒæœ€å¤§5ä½“ã‚’ç½®ãï¼‰ -->
        <div id="setup-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>å¯¾æˆ¦æº–å‚™</h2>
                <p>æ‰‹æœ­ã‹ã‚‰ãƒãƒˆãƒ«å ´ã«1ä½“ã€ãƒ™ãƒ³ãƒã«5ä½“ã¾ã§ãƒã‚±ãƒ¢ãƒ³ã‚’é…ç½®ã—ã¦ãã ã•ã„ã€‚</p>
                <div class="setup-area">
                    <h3>ãƒãƒˆãƒ«å ´</h3>
                    <div class="setup-slots"><div id="setup-battle-slot" class="setup-slot battle"></div></div>
                </div>
                <div class="setup-area">
                    <h3>ãƒ™ãƒ³ãƒ</h3>
                    <div id="setup-bench-slots" class="setup-slots"></div>
                </div>
                <div id="setup-hand-zone" class="hand-zone"></div>
                <button id="finish-setup-button" class="control-button" disabled>æº–å‚™å®Œäº†</button>
            </div>
        </div>

        <!-- ããœã¤å¾Œã®ãƒãƒˆãƒ«æ˜‡æ ¼é¸æŠ -->
        <div id="promotion-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>ãƒãƒˆãƒ«ãƒã‚±ãƒ¢ãƒ³ãŒããœã¤ã—ã¾ã—ãŸï¼</h2>
                <p>ãƒ™ãƒ³ãƒã‹ã‚‰æ–°ã—ã„ãƒãƒˆãƒ«ãƒã‚±ãƒ¢ãƒ³ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>
                <div id="promotion-options"></div>
            </div>
        </div>

        <!-- â˜…è¿½åŠ ï¼šãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆã®ãƒ™ãƒ³ãƒé¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="switch-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>ãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆ</h2>
                <p>ãƒãƒˆãƒ«å ´ã¨å…¥ã‚Œæ›¿ãˆã‚‹ãƒ™ãƒ³ãƒã®ãƒã‚±ãƒ¢ãƒ³ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>
                <div id="switch-options"></div>
            </div>
        </div>

        <!-- ã‚²ãƒ¼ãƒ çµ‚äº†è¡¨ç¤º -->
        <!-- â˜…è¿½åŠ ï¼šãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆã®ãƒ™ãƒ³ãƒé¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="switch-modal" class="modal-overlay hidden">
  <div class="modal-content">
    <h2>ãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆ</h2>
    <p>ãƒãƒˆãƒ«å ´ã¨å…¥ã‚Œæ›¿ãˆã‚‹ãƒ™ãƒ³ãƒã®ãƒã‚±ãƒ¢ãƒ³ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>
    <div id="switch-options"></div>
  </div>
</div>
        <div id="game-over-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2 id="game-over-message"></h2>
                <button id="play-again-button" class="control-button">ã‚‚ã†ä¸€åº¦éŠã¶</button>
            </div>
        </div>

        <!-- ã‚¿ãƒ¼ãƒ³ã®å¤§å‹ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¢ã‚¦ãƒˆï¼‰ -->
        <div id="turn-announcement-modal" class="modal-overlay hidden">
            <div class="modal-content bg-transparent text-white text-6xl font-bold">
                <h2 id="turn-announcement-text"></h2>
            </div>
        </div>

        <!-- ========== ãƒ¡ã‚¤ãƒ³UIï¼ˆã‚¿ãƒ¼ãƒ³è¡¨ç¤ºï¼ãƒ­ã‚°ï¼ç›¤é¢ï¼æ“ä½œãƒœã‚¿ãƒ³ï¼‰ ========== -->
        <div class="game-info hidden" id="game-info-area">
            <div id="turn-indicator"></div>
            <div id="log"></div>
        </div>

        <div class="game-board hidden" id="game-board-area">
            <!-- ç›¸æ‰‹é ˜åŸŸï¼šãƒãƒˆãƒ«ãƒ»ãƒ™ãƒ³ãƒãƒ»æ‰‹æœ­ãƒ»ã‚µã‚¤ãƒ‰/å±±æœ­/ãƒˆãƒ©ãƒƒã‚·ãƒ¥ -->
            <div class="player-area" id="opponent-area">
                <div class="main-area">
                    <div class="battle-zone" id="opponent-battle-zone"></div>
                    <div class="bench-zone" id="opponent-bench"></div>
                </div>
                <div class="hand-zone" id="opponent-hand"></div>
                <div class="side-area">
                    <div class="prize-area" id="opponent-prize-area">ã‚µã‚¤ãƒ‰: 0/3</div>
                    <div class="discard-pile" id="opponent-discard-pile"><span>ãƒˆãƒ©ãƒƒã‚·ãƒ¥</span><span id="opponent-discard-count">0</span></div>
                    <div class="deck-zone" id="opponent-deck"><span>å±±æœ­</span><span id="opponent-deck-count"></span></div>
                </div>
            </div>

            <!-- è‡ªåˆ†é ˜åŸŸ -->
            <div class="player-area" id="player-area">
                <div class="main-area">
                    <div class="battle-zone" id="player-battle-zone"></div>
                    <div class="bench-zone" id="player-bench"></div>
                </div>
                <div class="hand-zone" id="player-hand"></div>
                <div class="side-area">
                    <div class="prize-area" id="player-prize-area">ã‚µã‚¤ãƒ‰: 0/3</div>
                    <div class="discard-pile" id="player-discard-pile"><span>ãƒˆãƒ©ãƒƒã‚·ãƒ¥</span><span id="player-discard-count">0</span></div>
                    <div class="deck-zone" id="player-deck"><span>å±±æœ­</span><span id="player-deck-count"></span></div>
                </div>
            </div>
        </div>

        <div class="game-controls hidden" id="game-controls-area">
            <button id="end-turn-button" class="control-button">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
        </div>
    </div>

    <script>
        // ==============================================================
        //  ãƒ‡ãƒ¼ã‚¿å®šç¾©ï¼†ã‚²ãƒ¼ãƒ çŠ¶æ…‹ï¼ˆStateï¼‰
        // ==============================================================

        /* ã‚«ãƒ¼ãƒ‰ã€Œãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã€ï¼šã“ã“ã‹ã‚‰ãƒ‡ãƒƒã‚­ã‚’çµ„ã‚€ */
        const cardDatabase = [
            // ãƒã‚±ãƒ¢ãƒ³ï¼ˆname, hp, attack, speed, emojiï¼‰
            { cardType: 'pokemon', id: 1, name: "ãƒªã‚¶ãƒ¼ãƒ‰ãƒ³", hp: 150, attack: 100, speed: 60, emoji: "ğŸ”¥" },
            { cardType: 'pokemon', id: 2, name: "ã‚«ãƒ¡ãƒƒã‚¯ã‚¹",   hp: 160, attack: 90,  speed: 50, emoji: "ğŸ’§" },
            { cardType: 'pokemon', id: 3, name: "ãƒ•ã‚·ã‚®ãƒãƒŠ",   hp: 170, attack: 80,  speed: 40, emoji: "ğŸŒ¿" },
            { cardType: 'pokemon', id: 4, name: "ãƒ”ã‚«ãƒãƒ¥ã‚¦",   hp: 60,  attack: 40,  speed: 90, emoji: "âš¡ï¸" },
            { cardType: 'pokemon', id: 5, name: "ãƒŸãƒ¥ã‚¦ãƒ„ãƒ¼",   hp: 180, attack: 120, speed: 40, emoji: "ğŸ”®" },
            { cardType: 'pokemon', id: 6, name: "ã‚«ãƒ“ã‚´ãƒ³",     hp: 200, attack: 70,  speed: 30, emoji: "ğŸ˜´" },
            { cardType: 'pokemon', id: 7, name: "ã‚¤ãƒ¼ãƒ–ã‚¤",     hp: 50,  attack: 30,  speed: 100,emoji: "ğŸ¾" },
            { cardType: 'pokemon', id: 8, name: "ã‚®ãƒ£ãƒ©ãƒ‰ã‚¹",   hp: 150, attack: 110, speed: 70, emoji: "ğŸŒŠ" },
            { cardType: 'pokemon', id: 9, name: "ãã‚“ã«ãã‚“",   hp: 100, attack: 150, speed: 30, emoji: "ğŸ’ªğŸ»" },

            // ã‚°ãƒƒã‚ºï¼ˆå³æ™‚åŠ¹æœï¼‰
            { cardType: 'goods', id: 101, name: "ã‚­ã‚ºãã™ã‚Š",     emoji: "ğŸ©¹", desc: "è‡ªåˆ†ã®ãƒãƒˆãƒ«ãƒã‚±ãƒ¢ãƒ³ã®HPã‚’ã€Œ30ã€å›å¾©ã™ã‚‹ã€‚", effect: 'healActive30' },
            // â˜…è¿½åŠ ï¼šãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆï¼ˆã‚°ãƒƒã‚ºï¼‰
            { cardType: 'goods', id: 102, name: "ãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆ", emoji: "ğŸ”", desc: "è‡ªåˆ†ã®ãƒãƒˆãƒ«ãƒã‚±ãƒ¢ãƒ³ã¨ãƒ™ãƒ³ãƒã®1ä½“ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã€‚", effect: 'switchActive' },

            // ã‚µãƒãƒ¼ãƒˆï¼ˆã‚¿ãƒ¼ãƒ³ã«1å›ã®å¼·åŠ›åŠ¹æœï¼‰
            { cardType: 'support', id: 201, name: "åšå£«ã®ç ”ç©¶", emoji: "ğŸ‘¨â€ğŸ”¬", desc: "è‡ªåˆ†ã®æ‰‹æœ­ã‚’ã™ã¹ã¦ãƒˆãƒ©ãƒƒã‚·ãƒ¥ã—ã€å±±æœ­ã‚’7æšå¼•ãã€‚", effect: 'professorsResearch' },
            { cardType: 'support', id: 202, name: "ã‚¸ãƒ£ãƒƒã‚¸ãƒãƒ³", emoji: "âš–ï¸", desc: "ãŠãŸãŒã„ã®æ‰‹æœ­ã‚’å±±æœ­ã«æˆ»ã—ã¦åˆ‡ã‚Šç›´ã—ã€4æšå¼•ãã€‚", effect: 'judgeman' }
        ];

        // ä¸»è¦ãªçŠ¶æ…‹å¤‰æ•°ï¼ˆé…åˆ—ãªã©ï¼‰
        let playerDeck, opponentDeck, playerHand, opponentHand, playerBench, opponentBench, playerDiscard, opponentDiscard;
        let playerBattleCard = null, opponentBattleCard = null; // ãƒãƒˆãƒ«å ´ã®ã‚«ãƒ¼ãƒ‰
        let playerPrizes, opponentPrizes;                        // ã‚µã‚¤ãƒ‰æšæ•°ï¼ˆ0ã‹ã‚‰ã‚«ã‚¦ãƒ³ãƒˆï¼‰
        let currentTurn = 'player', playerHasPlayedSupport = false, isGameOver = false;
        let selectedCardIndex = null; // æº–å‚™ãƒ•ã‚§ãƒ¼ã‚ºã§æ‰‹æœ­ã‹ã‚‰é¸æŠä¸­ã®ã‚«ãƒ¼ãƒ‰ä½ç½®

        // ==============================================================
        //  DOMå‚ç…§ï¼ˆdocument.getElementByIdã®é›†ç´„ï¼‰
        // ==============================================================

        const dom = {
            player: {
                area: document.getElementById('player-area'),
                hand: document.getElementById('player-hand'),
                battle: document.getElementById('player-battle-zone'),
                bench: document.getElementById('player-bench'),
                deckCount: document.getElementById('player-deck-count'),
                prize: document.getElementById('player-prize-area'),
                discardCount: document.getElementById('player-discard-count')
            },
            opponent: {
                area: document.getElementById('opponent-area'),
                hand: document.getElementById('opponent-hand'),
                battle: document.getElementById('opponent-battle-zone'),
                bench: document.getElementById('opponent-bench'),
                deckCount: document.getElementById('opponent-deck-count'),
                prize: document.getElementById('opponent-prize-area'),
                discardCount: document.getElementById('opponent-discard-count')
            },
            modals: {
                start: document.getElementById('start-game-modal'),
                setup: document.getElementById('setup-modal'),
                promotion: document.getElementById('promotion-modal'),
                gameOver: document.getElementById('game-over-modal'),
                turnAnnouncement: document.getElementById('turn-announcement-modal'),
                // â˜…è¿½åŠ ï¼šå…¥ã‚Œæ›¿ãˆç”¨ãƒ¢ãƒ¼ãƒ€ãƒ«
                switch: document.getElementById('switch-modal')
            },
            setup: {
                hand: document.getElementById('setup-hand-zone'),
                battleSlot: document.getElementById('setup-battle-slot'),
                benchSlots: document.getElementById('setup-bench-slots'),
                finishButton: document.getElementById('finish-setup-button')
            },
            controls: {
                endTurn: document.getElementById('end-turn-button'),
                startGame: document.getElementById('start-game-button'),
                playAgain: document.getElementById('play-again-button')
            },
            info: {
                turn: document.getElementById('turn-indicator'),
                log: document.getElementById('log'),
                gameOverMsg: document.getElementById('game-over-message'),
                promotionOptions: document.getElementById('promotion-options'),
                turnAnnouncementText: document.getElementById('turn-announcement-text'),
                // â˜…è¿½åŠ ï¼šå…¥ã‚Œæ›¿ãˆå€™è£œã®ç½®ãå ´
                switchOptions: document.getElementById('switch-options')
            },
            containers: {
                info: document.getElementById('game-info-area'),
                board: document.getElementById('game-board-area'),
                controls: document.getElementById('game-controls-area')
            }
        };

        // ==============================================================
        //  ã‚²ãƒ¼ãƒ é€²è¡Œï¼ˆã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼ï¼‰
        // ==============================================================

        function initializeGame() {
            [playerDeck, opponentDeck, playerHand, opponentHand, playerBench, opponentBench, playerDiscard, opponentDiscard] = [[], [], [], [], [], [], [], []];
            [playerBattleCard, opponentBattleCard, selectedCardIndex] = [null, null, null];
            [playerPrizes, opponentPrizes] = [0, 0];
            [currentTurn, playerHasPlayedSupport, isGameOver] = ['player', false, false];

            dom.info.log.innerHTML = '';
            Object.values(dom.modals).forEach(m => m.classList.add('hidden'));
            dom.modals.start.classList.remove('hidden');

            // ãƒ‡ãƒƒã‚­ç”Ÿæˆï¼†ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆç›¸æ‰‹ã‚‚åŒã˜æ§‹æˆï¼‰
            playerDeck = createDeck();
            opponentDeck = createDeck();
            shuffleDeck(playerDeck);
            shuffleDeck(opponentDeck);

            for (let i = 0; i < 7; i++) { drawCard('player'); drawCard('opponent'); }

            dom.modals.start.classList.add('hidden');
            startSetupPhase();
        }

        function startSetupPhase() {
            opponentSetup();
            renderSetupModal();
            dom.modals.setup.classList.remove('hidden');
        }

        function finishSetup() {
            if (!playerBattleCard) { addLog("ãƒãƒˆãƒ«å ´ã«ãƒã‚±ãƒ¢ãƒ³ã‚’ç½®ã„ã¦ãã ã•ã„ã€‚"); return; }
            dom.modals.setup.classList.add('hidden');

            Object.values(dom.containers).forEach(c => c.classList.remove('hidden'));
            addLog("å¯¾æˆ¦é–‹å§‹ï¼");
            startPlayerTurn(false);
        }

        async function startPlayerTurn(shouldDraw = true) {
            if (isGameOver) return;
            currentTurn = 'player';
            playerHasPlayedSupport = false;
            dom.controls.endTurn.disabled = false;
            dom.player.area.classList.add('active-player');
            dom.opponent.area.classList.remove('active-player');

            await showTurnAnnouncement("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³");

            if (shouldDraw) {
                drawCard('player');
                if (isGameOver) return;
                addLog("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã€‚å±±æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ã„ãŸã€‚");
            } else {
                addLog("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚");
            }
            updateAllUI();
        }

        async function endTurn() {
            if (isGameOver || currentTurn !== 'player') return;
            dom.controls.endTurn.disabled = true;
            addLog("--- ãƒãƒˆãƒ«ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ ---");
            await executeBattlePhase();
            if (!isGameOver) { opponentTurn(); }
        }

        async function opponentTurn() {
            if (isGameOver) return;
            currentTurn = 'opponent';
            dom.player.area.classList.remove('active-player');
            dom.opponent.area.classList.add('active-player');

            await showTurnAnnouncement("ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³");

            addLog("ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚");
            await new Promise(r => setTimeout(r, 500));
            drawCard('opponent');
            if (isGameOver) return;
            addLog("ç›¸æ‰‹ã¯å±±æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ã„ãŸã€‚");
            updateAllUI();

            await opponentActions();

            if (!isGameOver) {
                addLog("--- ãƒãƒˆãƒ«ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ ---");
                await executeBattlePhase();
            }
            if (!isGameOver) { startPlayerTurn(); }
        }

        // ==============================================================
        //  AIãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå±•é–‹â†’ã‚µãƒãƒ¼ãƒˆâ†’å…¥ã‚Œæ›¿ãˆâ†’å›å¾©ï¼‰
        // ==============================================================
        async function opponentActions() {
            const delay = () => new Promise(r => setTimeout(r, 800));

            // ãƒ™ãƒ³ãƒå±•é–‹
            while (opponentHand.some(c => c.cardType === 'pokemon') && opponentBench.length < 5) {
                const idx = opponentHand.findIndex(c => c.cardType === 'pokemon');
                const card = opponentHand[idx];
                opponentBench.push({ ...opponentHand.splice(idx, 1)[0], currentHp: card.hp });
                addLog(`ç›¸æ‰‹ã¯ ${card.name} ã‚’ãƒ™ãƒ³ãƒã«å‡ºã—ãŸã€‚`);
                updateAllUI();
                await delay();
            }

            // ã‚µãƒãƒ¼ãƒˆä½¿ç”¨ï¼ˆç°¡æ˜“æ¡ä»¶ï¼‰
            const supportInHand = opponentHand.find(c => c.cardType === 'support');
            if (supportInHand) {
                let useSupport = false;
                if (supportInHand.effect === 'judgeman' && playerHand.length >= opponentHand.length + 3) useSupport = true;
                else if (supportInHand.effect === 'professorsResearch' && opponentHand.length <= 3) useSupport = true;
                if (useSupport) {
                    const supportIndex = opponentHand.indexOf(supportInHand);
                    executeEffect(supportInHand, 'opponent');
                    opponentDiscard.push(opponentHand.splice(supportIndex, 1)[0]);
                    updateAllUI();
                    await delay();
                }
            }

            // â˜…è¿½åŠ ï¼šãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆï¼ˆæ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ”»æ’ƒã§ç¾ãƒãƒˆãƒ«ãŒå€’ã‚Œãã†ï¼†ãƒ™ãƒ³ãƒã«ç”Ÿå­˜ã§ãã‚‹ãƒã‚±ãƒ¢ãƒ³ãŒã„ã‚Œã°ä½¿ç”¨ï¼‰
            const switchCard = opponentHand.find(c => c.cardType === 'goods' && c.effect === 'switchActive');
            if (switchCard && opponentBattleCard && playerBattleCard) {
                const nextPlayerAtk = playerBattleCard.attack;
                const willKOCurr = nextPlayerAtk >= opponentBattleCard.currentHp;
                const survivable = opponentBench
                    .map((c, i) => ({ i, c }))
                    .filter(x => x.c.currentHp > nextPlayerAtk); // æ¬¡ã®æ”»æ’ƒã‚’è€ãˆã‚‹

                if (willKOCurr && survivable.length > 0) {
                    // è€ãˆã‚‹ä¸­ã§HPã®é«˜ã„å€‹ä½“ã‚’å„ªå…ˆ
                    survivable.sort((a,b) => b.c.currentHp - a.c.currentHp);
                    const targetIndex = survivable[0].i;

                    executeEffect(switchCard, 'opponent', targetIndex); // aiSwitchIndexã‚’æ¸¡ã™
                    opponentDiscard.push(opponentHand.splice(opponentHand.indexOf(switchCard), 1)[0]);
                    updateAllUI();
                    await delay();
                }
            }

            // å›å¾©ã‚°ãƒƒã‚ºï¼šæ¬¡ã®ç›¸æ‰‹æ”»æ’ƒã§å€’ã•ã‚Œãã†ãªã‚‰ä½¿ã†
            const potionInHand = opponentHand.find(c => c.effect === 'healActive30');
            if (potionInHand && opponentBattleCard && opponentBattleCard.currentHp < opponentBattleCard.hp) {
                const canBeKOd = playerBattleCard ? playerBattleCard.attack >= opponentBattleCard.currentHp : false;
                if (canBeKOd) {
                    const pIdx = opponentHand.indexOf(potionInHand);
                    executeEffect(potionInHand, 'opponent');
                    opponentDiscard.push(opponentHand.splice(pIdx, 1)[0]);
                    updateAllUI();
                    await delay();
                }
            }
        }

        // ==============================================================
        //  ãƒãƒˆãƒ«
        // ==============================================================
        async function executeBattlePhase() {
            if (!playerBattleCard || !opponentBattleCard) return;

            const playerSpeed = playerBattleCard.speed;
            const opponentSpeed = opponentBattleCard.speed;
            let firstAttacker, secondAttacker;

            if (playerSpeed > opponentSpeed) {
                firstAttacker = 'player';   secondAttacker = 'opponent';
                addLog(`${playerBattleCard.name}ã®ç´ æ—©ã•ãŒé«˜ã„ï¼å…ˆã«æ”»æ’ƒï¼`);
            } else if (opponentSpeed > playerSpeed) {
                firstAttacker = 'opponent'; secondAttacker = 'player';
                addLog(`${opponentBattleCard.name}ã®ç´ æ—©ã•ãŒé«˜ã„ï¼å…ˆã«æ”»æ’ƒï¼`);
            } else {
                addLog("ç´ æ—©ã•ãŒåŒã˜ï¼ã‚³ã‚¤ãƒ³ãƒˆã‚¹...");
                await new Promise(r => setTimeout(r, 500));
                if (Math.random() < 0.5) { firstAttacker = 'player';   secondAttacker = 'opponent'; addLog("çµæœã¯ã‚ªãƒ¢ãƒ†ï¼ã‚ãªãŸãŒå…ˆæ”»ï¼"); }
                else                     { firstAttacker = 'opponent'; secondAttacker = 'player';   addLog("çµæœã¯ã‚¦ãƒ©ï¼ç›¸æ‰‹ãŒå…ˆæ”»ï¼"); }
            }

            await new Promise(r => setTimeout(r, 1000));
            await performAttack(firstAttacker, secondAttacker);
            if (isGameOver || !playerBattleCard || !opponentBattleCard) return;

            await new Promise(r => setTimeout(r, 1500));
            await performAttack(secondAttacker, firstAttacker);
        }

        async function performAttack(attackerType, defenderType) {
            if (isGameOver || !playerBattleCard || !opponentBattleCard) return;
            const attacker = attackerType === 'player' ? playerBattleCard : opponentBattleCard;
            const defender = defenderType === 'player' ? playerBattleCard : opponentBattleCard;

            addLog(`${attackerType === 'player' ? 'ã‚ãªãŸ' : 'ç›¸æ‰‹'}ã® ${attacker.name} ã®æ”»æ’ƒï¼`);
            await new Promise(r => setTimeout(r, 500));

            defender.currentHp -= attacker.attack;
            addLog(`${defender.name} ã« ${attacker.attack} ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
            updateAllUI();

            await new Promise(r => setTimeout(r, 500));
            await checkKnockout(defenderType);
        }

        async function checkKnockout(knockedOutPlayer) {
            if (isGameOver) return;
            const isPlayerKnockedOut = knockedOutPlayer === 'player';
            let targetCard = isPlayerKnockedOut ? playerBattleCard : opponentBattleCard;

            if (targetCard && targetCard.currentHp <= 0) {
                addLog(`${targetCard.name} ã¯ããœã¤ã—ãŸï¼`);
                (isPlayerKnockedOut ? playerDiscard : opponentDiscard).push(targetCard);

                if (isPlayerKnockedOut) { opponentPrizes++; addLog(`ç›¸æ‰‹ã¯ã‚µã‚¤ãƒ‰ã‚’1æšå–ã£ãŸã€‚(æ®‹ã‚Š ${3 - opponentPrizes}æš)`); }
                else                    { playerPrizes++;  addLog(`ã‚ãªãŸã¯ã‚µã‚¤ãƒ‰ã‚’1æšå–ã£ãŸã€‚(æ®‹ã‚Š ${3 - playerPrizes}æš)`); }
                updateAllUI();

                if (playerPrizes >= 3)   { endGame('player',   'ã‚µã‚¤ãƒ‰ã‚’3æšå–ã‚Šã¾ã—ãŸã€‚');   return; }
                if (opponentPrizes >= 3) { endGame('opponent', 'ã‚µã‚¤ãƒ‰ã‚’3æšå–ã‚Šã¾ã—ãŸã€‚'); return; }

                if (isPlayerKnockedOut) playerBattleCard = null; else opponentBattleCard = null;
                const bench = isPlayerKnockedOut ? playerBench : opponentBench;

                if (bench.length > 0) {
                    if (isPlayerKnockedOut) {
                        promptPromotion();
                    } else {
                        addLog("ç›¸æ‰‹ã¯æ–°ã—ã„ãƒã‚±ãƒ¢ãƒ³ã‚’å‡ºã™ã‚ˆã†ã ...");
                        await new Promise(r => setTimeout(r, 1500));
                        promoteToBattle(null, 'opponent');
                        updateAllUI();
                    }
                } else {
                    endGame(isPlayerKnockedOut ? 'opponent' : 'player', `å ´ã®ãƒã‚±ãƒ¢ãƒ³ãŒã„ãªããªã‚Šã¾ã—ãŸã€‚`);
                }
            }
        }

        function endGame(winner, reason) {
            if (isGameOver) return;
            isGameOver = true;
            dom.info.gameOverMsg.textContent = `${winner === 'player' ? 'ã‚ãªãŸã®å‹åˆ©ï¼' : 'ã‚ãªãŸã®è² ã‘...'} (${reason})`;
            dom.modals.gameOver.classList.remove('hidden');
            dom.containers.controls.classList.add('hidden');
        }

        // ==============================================================
        //  ã‚«ãƒ¼ãƒ‰æ“ä½œï¼ˆãƒ‡ãƒƒã‚­æ§‹ç¯‰ï¼ãƒ‰ãƒ­ãƒ¼ï¼ãƒ—ãƒ¬ã‚¤ï¼åŠ¹æœï¼‰
        // ==============================================================

        function createDeck() {
            const p = cardDatabase.filter(c => c.cardType === 'pokemon');
            const g = cardDatabase.filter(c => c.cardType === 'goods');
            const s = cardDatabase.filter(c => c.cardType === 'support');
            let deck = [];
            for (let i = 0; i < 3; i++) deck.push(...p); // ãƒã‚±ãƒ¢ãƒ³3å·¡
            deck.push(...g, ...g);
            deck.push(...s, ...s);
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function drawCard(playerType) {
            if (isGameOver) return;
            const isPlayer = playerType === 'player';
            const deck = isPlayer ? playerDeck : opponentDeck;
            if (deck.length === 0) {
                endGame(isPlayer ? 'opponent' : 'player', 'å±±æœ­ãŒãªããªã‚Šã¾ã—ãŸã€‚');
                return;
            }
            (isPlayer ? playerHand : opponentHand).push(deck.pop());
        }

        function playCardFromHand(handIndex) {
            if (currentTurn !== 'player' || isGameOver) return;
            const card = playerHand[handIndex];

            switch(card.cardType) {
                case 'pokemon':
                    if (!playerBattleCard) {
                        playerBattleCard = { ...playerHand.splice(handIndex, 1)[0], currentHp: card.hp };
                        addLog(`${card.name}ã‚’ãƒãƒˆãƒ«å ´ã«å‡ºã—ãŸã€‚`);
                    } else if (playerBench.length < 5) {
                        playerBench.push({ ...playerHand.splice(handIndex, 1)[0], currentHp: card.hp });
                        addLog(`${card.name}ã‚’ãƒ™ãƒ³ãƒã«å‡ºã—ãŸã€‚`);
                    } else {
                        addLog("ãƒ™ãƒ³ãƒãŒã„ã£ã±ã„ã§ã™ï¼");
                        return;
                    }
                    break;

                case 'goods':
                    // â˜…å…¥ã‚Œæ›¿ãˆã¯é¸æŠãŒå¿…è¦ã ãŒã€ç°¡æ˜“å®Ÿè£…ã¨ã—ã¦å…ˆã«åŠ¹æœâ†’ã™ããƒˆãƒ©ãƒƒã‚·ãƒ¥
                    executeEffect(card, 'player');
                    playerDiscard.push(playerHand.splice(handIndex, 1)[0]);
                    break;

                case 'support':
                    if (playerHasPlayedSupport) {
                        addLog("ã“ã®ç•ªã€ã™ã§ã«ã‚µãƒãƒ¼ãƒˆã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚");
                        return;
                    }
                    playerHasPlayedSupport = true;
                    executeEffect(card, 'player');
                    playerDiscard.push(playerHand.splice(handIndex, 1)[0]);
                    break;
            }
            updateAllUI();
        }

        function executeEffect(card, playerType, aiSwitchIndex = null) {
            addLog(`${playerType === 'player' ? 'ã‚ãªãŸ' : 'ç›¸æ‰‹'}ã¯ã€Œ${card.name}ã€ã‚’ä½¿ã£ãŸï¼`);
            const isPlayer = playerType === 'player';

            switch(card.effect) {
                case 'healActive30': {
                    let target = isPlayer ? playerBattleCard : opponentBattleCard;
                    if (target) { target.currentHp = Math.min(target.hp, target.currentHp + 30); }
                    break;
                }
                case 'professorsResearch': {
                    const handToDiscard = isPlayer ? playerHand : opponentHand;
                    const discardPile = isPlayer ? playerDiscard : opponentDiscard;
                    while(handToDiscard.length > 0) discardPile.push(handToDiscard.pop());
                    for (let i = 0; i < 7; i++) drawCard(playerType);
                    break;
                }
                case 'judgeman': {
                    [playerHand, opponentHand].forEach((h, i) => {
                        const d = i === 0 ? playerDeck : opponentDeck;
                        while(h.length > 0) d.push(h.pop());
                        shuffleDeck(d);
                    });
                    for (let j = 0; j < 4; j++) drawCard('player');
                    for (let j = 0; j < 4; j++) drawCard('opponent');
                    break;
                }
                // â˜…è¿½åŠ ï¼šãƒã‚±ãƒ¢ãƒ³å…¥ã‚Œæ›¿ãˆ
                case 'switchActive': {
                    if (isPlayer) {
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ãƒ™ãƒ³ãƒã‹ã‚‰é¸æŠ
                        if (!playerBattleCard || playerBench.length === 0) {
                            addLog("å…¥ã‚Œæ›¿ãˆã‚‹ãƒã‚±ãƒ¢ãƒ³ãŒã„ã¾ã›ã‚“ã€‚");
                            break;
                        }
                        promptSwitch();
                    } else {
                        // AIã¯æŒ‡å®šã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§å³å…¥ã‚Œæ›¿ãˆ
                        if (aiSwitchIndex !== null && opponentBench[aiSwitchIndex]) {
                            swapActiveWithBench('opponent', aiSwitchIndex);
                        }
                    }
                    break;
                }
            }
        }

        // ==============================================================
        //  å…¥ã‚Œæ›¿ãˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼UIï¼†å…±é€šå‡¦ç†ï¼‰
        // ==============================================================
        function promptSwitch() {
            dom.info.switchOptions.innerHTML = '';
            playerBench.forEach((card, index) => {
                const el = createCardElement(card, 'player', true);
                el.addEventListener('click', () => {
                    swapActiveWithBench('player', index);
                    dom.modals.switch.classList.add('hidden');
                    updateAllUI();
                });
                dom.info.switchOptions.appendChild(el);
            });
            dom.modals.switch.classList.remove('hidden');
        }

        function swapActiveWithBench(playerType, benchIndex) {
            const isPlayer = playerType === 'player';
            const bench = isPlayer ? playerBench : opponentBench;

            if (benchIndex < 0 || benchIndex >= bench.length) return;
            if (isPlayer && !playerBattleCard) return;
            if (!isPlayer && !opponentBattleCard) return;

            if (isPlayer) {
                const temp = playerBattleCard;
                playerBattleCard = bench[benchIndex];
                bench[benchIndex] = temp;
            } else {
                const temp = opponentBattleCard;
                opponentBattleCard = bench[benchIndex];
                bench[benchIndex] = temp;
            }
            addLog(`${isPlayer ? 'ã‚ãªãŸ' : 'ç›¸æ‰‹'}ã¯ãƒãƒˆãƒ«ãƒã‚±ãƒ¢ãƒ³ã‚’å…¥ã‚Œæ›¿ãˆãŸï¼`);
        }

        // ==============================================================
        //  æº–å‚™ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆåˆæœŸé…ç½®UIï¼‰
        // ==============================================================
        function opponentSetup() {
            const pokemonInHand = opponentHand.filter(c => c.cardType === 'pokemon');

            if (pokemonInHand.length === 0) {
                addLog("ç›¸æ‰‹ã®æ‰‹æœ­ã«ãƒã‚±ãƒ¢ãƒ³ãŒãªãã€ãƒãƒªã‚¬ãƒ³ã—ã¾ã™ã€‚");
                while(opponentHand.length > 0) opponentDeck.push(opponentHand.pop());
                shuffleDeck(opponentDeck);
                for (let i = 0; i < 7; i++) drawCard('opponent');
                setTimeout(opponentSetup, 500);
                return;
            }

            pokemonInHand.sort((a, b) => b.hp - a.hp);
            const bestPokemon = pokemonInHand.shift();
            const bestPokemonIndex = opponentHand.findIndex(c => c.id === bestPokemon.id && c.cardType === 'pokemon');
            promoteToBattle(bestPokemonIndex, 'opponent', true);

            while (opponentHand.some(c => c.cardType === 'pokemon') && opponentBench.length < 5) {
                const pIndex = opponentHand.findIndex(c => c.cardType === 'pokemon');
                const card = { ...opponentHand.splice(pIndex, 1)[0] };
                card.currentHp = card.hp;
                opponentBench.push(card);
            }
        }

        function renderSetupModal() {
            dom.setup.hand.innerHTML = '';
            playerHand.forEach((card, index) => {
                const el = createCardElement(card, 'player');
                if (selectedCardIndex === index) el.classList.add('selected');
                el.addEventListener('click', () => {
                    if(card.cardType === 'pokemon') {
                        selectedCardIndex = index; renderSetupModal();
                    } else {
                        addLog("æº–å‚™ä¸­ã¯ãƒã‚±ãƒ¢ãƒ³ã—ã‹å ´ã«å‡ºã›ã¾ã›ã‚“ã€‚")
                    }
                });
                dom.setup.hand.appendChild(el);
            });

            dom.setup.battleSlot.innerHTML = '';
            if (playerBattleCard) dom.setup.battleSlot.appendChild(createCardElement(playerBattleCard, 'player'));

            dom.setup.benchSlots.innerHTML = '';
            for (let i=0; i<5; i++) {
                const slot = document.createElement('div');
                slot.classList.add('setup-slot');
                if (playerBench[i]) {
                    slot.appendChild(createCardElement(playerBench[i], 'player'));
                } else {
                    slot.addEventListener('click', () => placeCardInSetup('bench', i));
                }
                dom.setup.benchSlots.appendChild(slot);
            }
            dom.setup.finishButton.disabled = !playerBattleCard;
        }

        function placeCardInSetup(zone, index) {
            if (selectedCardIndex === null) return;
            const card = playerHand[selectedCardIndex];
            if (card.cardType !== 'pokemon') return;

            playerHand.splice(selectedCardIndex, 1);
            card.currentHp = card.hp;

            if (zone === 'battle') {
                if (playerBattleCard) playerHand.push(playerBattleCard);
                playerBattleCard = card;
            } else {
                if (playerBench[index]) playerHand.push(playerBench[index]);
                playerBench[index] = card;
            }
            selectedCardIndex = null;
            renderSetupModal();
        }

        // ==============================================================
        //  UIæç”»ï¼ˆæ‰‹æœ­ï¼ãƒ™ãƒ³ãƒï¼ãƒãƒˆãƒ«ï¼ã‚«ã‚¦ãƒ³ãƒˆï¼ãƒ­ã‚°ï¼ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºï¼‰
        // ==============================================================
        function updateAllUI() {
            if (isGameOver) return;

            renderHand(playerHand, dom.player.hand, 'player');
            renderHand(opponentHand, dom.opponent.hand, 'opponent');
            renderBench(playerBench, dom.player.bench, 'player');
            renderBench(opponentBench, dom.opponent.bench, 'opponent');
            renderBattleZone(playerBattleCard, dom.player.battle, 'player');
            renderBattleZone(opponentBattleCard, dom.opponent.battle, 'opponent');

            updateDeckAndDiscardCounts();
            updatePrizes();

            dom.info.turn.textContent = currentTurn === 'player' ? 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³' : 'ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³';
            dom.controls.endTurn.disabled = currentTurn !== 'player';
        }

        function renderHand(hand, zone, playerType) {
            zone.innerHTML = '';
            hand.forEach((card, index) => {
                const el = createCardElement(card, playerType);
                if (playerType === 'player') el.addEventListener('click', () => playCardFromHand(index));
                zone.appendChild(el);
            });
        }

        function renderBench(bench, zone, playerType) {
            zone.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const p = document.createElement('div');
                Object.assign(p.style, { width: '80px', height: '112px', border: '2px dashed #4a5568', borderRadius: '0.5rem', flexShrink: '0' });
                if (bench[i]) zone.appendChild(createCardElement(bench[i], playerType, true));
                else zone.appendChild(p);
            }
        }

        function renderBattleZone(card, zone, playerType) {
            zone.innerHTML = '';
            if (card) {
                const el = createCardElement(card, playerType, true);
                el.classList.add('battle-card');
                zone.appendChild(el);
            }
        }

        function createCardElement(data, playerType, showDetails = false) {
            const card = document.createElement('div');
            card.classList.add('card', `${data.cardType}-card`);

            if (playerType === 'player' || showDetails) {
                let content = `<div class="card-name">${data.name}</div>`;
                if (data.cardType === 'pokemon') {
                    content += `
                        <div class="card-img">${data.emoji}</div>
                        <div class="card-stats"><span>HP:${data.hp}</span><span>ATK:${data.attack}</span><span>SPD:${data.speed}</span></div>
                        ${data.currentHp !== undefined ? `<div class="current-hp">${data.currentHp > 0 ? data.currentHp : 0}</div>` : ''}`;
                } else {
                    content += `<div class="card-desc">${data.desc}</div>`;
                }
                card.innerHTML = content;
            }
            return card;
        }

        function updateDeckAndDiscardCounts() {
            dom.player.deckCount.textContent = playerDeck.length;
            dom.opponent.deckCount.textContent = opponentDeck.length;
            dom.player.discardCount.textContent = playerDiscard.length;
            dom.opponent.discardCount.textContent = opponentDiscard.length;
        }

        function updatePrizes() {
            dom.player.prize.textContent   = `ã‚µã‚¤ãƒ‰: ${playerPrizes}/3`;
            dom.opponent.prize.textContent = `ã‚µã‚¤ãƒ‰: ${opponentPrizes}/3`;
        }

        function addLog(message) {
            const p = document.createElement('p');
            p.textContent = `> ${message}`;
            dom.info.log.insertBefore(p, dom.info.log.firstChild);
        }

        async function showTurnAnnouncement(message) {
            dom.info.turnAnnouncementText.textContent = message;
            dom.modals.turnAnnouncement.classList.remove('hidden');
            await new Promise(r => setTimeout(r, 2000));
            dom.modals.turnAnnouncement.classList.add('hidden');
        }

        // ==============================================================
        //  ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆUIãƒœã‚¿ãƒ³ãªã©ï¼‰
        // ==============================================================
        dom.controls.startGame.addEventListener('click', initializeGame);
        dom.controls.playAgain.addEventListener('click', () => {
            dom.modals.gameOver.classList.add('hidden');
            dom.modals.start.classList.remove('hidden');
        });
        dom.setup.finishButton.addEventListener('click', finishSetup);
        dom.setup.battleSlot.addEventListener('click', () => placeCardInSetup('battle'));
        dom.controls.endTurn.addEventListener('click', endTurn);
    </script>
</body>
</html>


